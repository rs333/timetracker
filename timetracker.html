<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Task Time Tracker</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 2em; }
        #timer { font-size: 2em; margin-bottom: 1em; }
        #toggleBtn { font-size: 1.2em; padding: 0.5em 1.5em; }
        #periods { margin-top: 2em; }
        table { border-collapse: collapse; width: 100%; }
        th, td { border: 1px solid #ccc; padding: 0.5em; text-align: left; }
        th { background: #f0f0f0; }
        .comment-input { width: 90%; }
    </style>
</head>
<body>
    <h1>Task Time Tracker</h1>
    <div id="timer">00:00:00</div>
    <button id="toggleBtn">Start</button>
    <div id="periods">
        <h2>Work Periods</h2>
        <table>
            <thead>
                <tr>
                    <th>Start Time</th>
                    <th>End Time</th>
                    <th>Duration</th>
                    <th>Comment</th>
                </tr>
            </thead>
            <tbody id="periodsBody">
            </tbody>
        </table>
    </div>
    <div id="summary">
        <h2>Weekly Summary</h2>
        <label for="weeksRange">Show last 
            <select id="weeksRange">
                <option value="4">4 weeks</option>
                <option value="8">8 weeks</option>
                <option value="12">12 weeks</option>
                <option value="24">24 weeks</option>
                <option value="52">52 weeks</option>
            </select>
        </label>
        <button id="refreshGraphBtn" style="margin-left:1em;">Refresh</button>
        <canvas id="weeklyBarChart" width="600" height="300"></canvas>
    </div>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script>
        let timerInterval = null;
        let startTime = null;
        let elapsed = 0;
        let periods = [];
        let barChart = null;
        let graphUpdateInterval = null;
        let lastGraphUpdate = 0;

        function saveTimerState() {
            if (startTime) {
                localStorage.setItem('timerInProgress', JSON.stringify({ startTime, elapsed }));
            } else {
                localStorage.removeItem('timerInProgress');
            }
        }

        function loadTimerState() {
            const data = localStorage.getItem('timerInProgress');
            if (data) {
                try {
                    const obj = JSON.parse(data);
                    if (obj && obj.startTime) {
                        startTime = obj.startTime;
                        elapsed = obj.elapsed || 0;
                        window.inProgressComment = localStorage.getItem('inProgressComment') || '';
                        // Resume timer
                        timerInterval = setInterval(updateTimerDisplay, 500);
                        document.getElementById('toggleBtn').textContent = 'Stop';
                        document.getElementById('toggleBtn').style.background = '#e74c3c';
                        setGraphUpdateInterval();
                    }
                } catch (e) {}
            }
        }

        function formatTime(ms) {
            const totalSeconds = Math.floor(ms / 1000);
            const hours = String(Math.floor(totalSeconds / 3600)).padStart(2, '0');
            const minutes = String(Math.floor((totalSeconds % 3600) / 60)).padStart(2, '0');
            const seconds = String(totalSeconds % 60).padStart(2, '0');
            return `${hours}:${minutes}:${seconds}`;
        }

        function updateTimerDisplay() {
            const now = Date.now();
            let display = elapsed;
            if (startTime) {
                display += now - startTime;
            }
            document.getElementById('timer').textContent = formatTime(display);
            renderPeriods(); // Update table live for in-progress period
            saveTimerState();
        }

        function renderPeriods() {
            const tbody = document.getElementById('periodsBody');
            tbody.innerHTML = '';
            // Show all completed periods, most recent first
            for (let i = periods.length - 1; i >= 0; i--) {
                const p = periods[i];
                const tr = document.createElement('tr');
                tr.innerHTML = `
                    <td>${p.start ? new Date(p.start).toLocaleString() : ''}</td>
                    <td>${p.end ? new Date(p.end).toLocaleString() : ''}</td>
                    <td>${p.end ? formatTime(p.end - p.start) : (p.start ? formatTime(Date.now() - p.start) : '')}</td>
                    <td>
                        <input class="comment-input" type="text" value="${p.comment || ''}" data-index="${i}" autocomplete="off" />
                    </td>
                `;
                tbody.appendChild(tr);
            }
            // Show current period in progress (if any)
            if (startTime) {
                // Only update the value of the input, not the whole element, if it already exists
                const prevInput = document.getElementById('inProgressComment');
                let prevSelectionStart = null, prevSelectionEnd = null;
                if (prevInput) {
                    prevSelectionStart = prevInput.selectionStart;
                    prevSelectionEnd = prevInput.selectionEnd;
                }
                let tr = document.getElementById('inProgressRow');
                if (!tr) {
                    tr = document.createElement('tr');
                    tr.id = 'inProgressRow';
                    tr.innerHTML = `
                        <td>${new Date(startTime).toLocaleString()}</td>
                        <td><em>In progress</em></td>
                        <td>${formatTime(Date.now() - startTime)}</td>
                        <td>
                            <input class="comment-input" type="text" id="inProgressComment" value="${window.inProgressComment || ''}" autocomplete="off" />
                        </td>
                    `;
                    tbody.insertBefore(tr, tbody.firstChild);
                    const input = document.getElementById('inProgressComment');
                    if (input) {
                        input.addEventListener('input', (e) => {
                            window.inProgressComment = e.target.value;
                            localStorage.setItem('inProgressComment', window.inProgressComment);
                        });
                    }
                } else {
                    // Only update the value and duration, not the whole row
                    const input = document.getElementById('inProgressComment');
                    if (input) {
                        if (input.value !== window.inProgressComment) {
                            input.value = window.inProgressComment || '';
                        }
                        if (prevSelectionStart !== null && prevSelectionEnd !== null && document.activeElement === input) {
                            input.setSelectionRange(prevSelectionStart, prevSelectionEnd);
                        }
                    }
                    // Update duration cell
                    tr.children[2].textContent = formatTime(Date.now() - startTime);
                }
            }
            document.querySelectorAll('.comment-input').forEach(input => {
                if (input.id !== 'inProgressComment') {
                    input.addEventListener('change', (e) => {
                        const idx = e.target.getAttribute('data-index');
                        periods[idx].comment = e.target.value;
                        savePeriods();
                    });
                }
            });
            setGraphUpdateInterval();
            renderWeeklyBarChart();
        }

        function savePeriods() {
            localStorage.setItem('workPeriods', JSON.stringify(periods));
        }

        function loadPeriods() {
            const data = localStorage.getItem('workPeriods');
            if (data) {
                periods = JSON.parse(data);
            }
        }

        function startTimer() {
            startTime = Date.now();
            elapsed = 0;
            window.inProgressComment = '';
            localStorage.removeItem('inProgressComment');
            timerInterval = setInterval(updateTimerDisplay, 500);
            document.getElementById('toggleBtn').textContent = 'Stop';
            document.getElementById('toggleBtn').style.background = '#e74c3c';
            setGraphUpdateInterval();
            saveTimerState();
        }

        function stopTimer() {
            clearInterval(timerInterval);
            timerInterval = null;
            const endTime = Date.now();
            periods.push({ start: startTime, end: endTime, comment: window.inProgressComment || '' });
            savePeriods();
            elapsed = 0;
            startTime = null;
            window.inProgressComment = '';
            localStorage.removeItem('inProgressComment');
            document.getElementById('timer').textContent = '00:00:00';
            document.getElementById('toggleBtn').textContent = 'Start';
            document.getElementById('toggleBtn').style.background = '';
            if (graphUpdateInterval) clearInterval(graphUpdateInterval);
            saveTimerState();
            renderPeriods(); // Move after resetting startTime to avoid extra row
            renderWeeklyBarChart(true); // Always update graph on stop
        }

        document.getElementById('toggleBtn').addEventListener('click', () => {
            if (timerInterval) {
                stopTimer();
            } else {
                startTimer();
            }
        });

        function getWeekStart(date) {
            const d = new Date(date);
            d.setHours(0,0,0,0);
            // Set to Monday (ISO week)
            const day = d.getDay();
            const diff = d.getDate() - day + (day === 0 ? -6 : 1);
            d.setDate(diff);
            return d;
        }

        function getWeeklySummary(periods, weeksBack) {
            const now = new Date();
            const weekMs = 7 * 24 * 60 * 60 * 1000;
            const weekStarts = [];
            const weekMap = {};
            // Find the start of the current week
            let currentWeekStart = getWeekStart(now);
            for (let i = 0; i < weeksBack; i++) {
                const weekKey = currentWeekStart.toISOString().slice(0,10);
                weekStarts.unshift(weekKey);
                weekMap[weekKey] = 0;
                currentWeekStart = new Date(currentWeekStart.getTime() - weekMs);
            }
            // Sum durations per week
            periods.forEach(p => {
                if (!p.start || !p.end) return;
                const start = new Date(p.start);
                const end = new Date(p.end);
                const weekKey = getWeekStart(start).toISOString().slice(0,10);
                if (weekKey in weekMap) {
                    weekMap[weekKey] += (end - start) / (1000 * 60 * 60); // hours
                }
            });
            // Add in-progress period if any
            if (startTime) {
                const now = Date.now();
                const weekKey = getWeekStart(startTime).toISOString().slice(0,10);
                if (weekKey in weekMap) {
                    weekMap[weekKey] += (now - startTime + (elapsed || 0)) / (1000 * 60 * 60); // hours
                }
            }
            return weekStarts.map(week => ({ week, hours: weekMap[week] }));
        }

        function renderWeeklyBarChart(force = false) {
            // Only update if at least 1 minute has passed or force is true
            const now = Date.now();
            if (!force && timerInterval && now - lastGraphUpdate < 60000) return;
            lastGraphUpdate = now;
            const weeksBack = parseInt(document.getElementById('weeksRange').value, 10);
            const summary = getWeeklySummary(periods, weeksBack);
            const ctx = document.getElementById('weeklyBarChart').getContext('2d');
            const labels = summary.map(s => s.week);
            const data = summary.map(s => s.hours.toFixed(2));
            if (barChart) barChart.destroy();
            barChart = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: labels,
                    datasets: [{
                        label: 'Hours Worked',
                        data: data,
                        backgroundColor: '#3498db',
                    }]
                },
                options: {
                    scales: {
                        y: {
                            beginAtZero: true,
                            title: { display: true, text: 'Hours' }
                        },
                        x: {
                            title: { display: true, text: 'Week Starting' }
                        }
                    }
                }
            });
        }

        document.getElementById('weeksRange').addEventListener('change', () => renderWeeklyBarChart(true));
        document.getElementById('refreshGraphBtn').addEventListener('click', () => renderWeeklyBarChart(true));

        function setGraphUpdateInterval() {
            if (graphUpdateInterval) clearInterval(graphUpdateInterval);
            if (timerInterval) {
                // Update graph every minute while timer is running
                graphUpdateInterval = setInterval(() => renderWeeklyBarChart(), 60000);
            }
        }

        // Initialize
        loadPeriods();
        loadTimerState();
        renderPeriods();
        updateTimerDisplay();
        window.addEventListener('DOMContentLoaded', () => renderWeeklyBarChart(true));
    </script>
</body>
</html>
